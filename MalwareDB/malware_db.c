#include "malware_db.h"
#include "../Database/database.h"
#include "../Logger/logger.h"
#include <stdio.h>
#include <string.h>
#include "../Database/sqlite3.h"

extern char DB_PATH[256];

void trim_quotes(char *str)
{
    if (str == NULL || *str == '\0')
        return;

    char *start = str;
    while (*start == ' ' || *start == '\t')
    {
        start++;
    }

    if (*start == '"')
    {
        start++;
    }

    if (start != str)
    {
        memmove(str, start, strlen(start) + 1);
    }

    int len = strlen(str);
    while (len > 0 && (str[len - 1] == '"' || str[len - 1] == '\n' || str[len - 1] == '\r' || str[len - 1] == ' '))
    {
        str[len - 1] = '\0';
        len--;
    }
}

int load_malware_csv(const char *csv_path, const char *source_name)
{
    FILE *fp = fopen(csv_path, "rb");
    if (fp == NULL) {
        log_error("Cannot open CSV file");
        return -1;
    }


    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    printf("File size: %ld bytes\n", file_size);

    sqlite3 *db;
    int rc = sqlite3_open(DB_PATH, &db);
    if (rc != SQLITE_OK) {
        log_error("Cannot open database");
        fclose(fp);
        return -1;
    }

    sqlite3_stmt *stmt;
    const char *sql = "INSERT OR IGNORE INTO malware_hashes (sha256, file_name, file_type, first_seen, reporter) "
                      "VALUES (?, ?, ?, ?, ?)";
    
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        log_error("Failed to prepare statement");
        sqlite3_close(db);
        fclose(fp);
        return -1;
    }

    sqlite3_exec(db, "PRAGMA synchronous = OFF", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA cache_size = 100000", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA temp_store = MEMORY", NULL, NULL, NULL);
    sqlite3_exec(db, "BEGIN TRANSACTION", NULL, NULL, NULL);

    char line[65536];
    int line_num = 0;
    int loaded = 0;      
    int skipped = 0;
    int errors = 0;
    int truncated = 0;

    printf("Starting CSV import from: %s\n", csv_path);

    while (fgets(line, sizeof(line), fp) != NULL) {
        line_num++;

        size_t len = strlen(line);

        if (len > 0 && line[len-1] != '\n' && !feof(fp)) {
            truncated++;
            if (truncated <= 20) { 
                printf("WARNING: Line %d truncated (len=%zu, too long)\n", line_num, len);
            }
            int c;
            while ((c = fgetc(fp)) != '\n' && c != EOF);
            skipped++;
            continue;
        }

        if (line[0] == '#') {
            continue;
        }

        if (strstr(line, "first_seen_utc") != NULL) {
            continue;
        }

        if (len < 10) {
            continue;
        }

        char *token;
        int col = 0;

        char first_seen[128] = "";
        char sha256[128] = "";
        char file_name[256] = "";
        char file_type[64] = "";

        token = strtok(line, ",");

        while (token != NULL) {
            trim_quotes(token);

            if (col == 0) {
                strncpy(first_seen, token, sizeof(first_seen) - 1);
                first_seen[sizeof(first_seen) - 1] = '\0';
            } else if (col == 1) {
                strncpy(sha256, token, sizeof(sha256) - 1);
                sha256[sizeof(sha256) - 1] = '\0';
            } else if (col == 5) {
                strncpy(file_name, token, sizeof(file_name) - 1);
                file_name[sizeof(file_name) - 1] = '\0';
            } else if (col == 6) {
                strncpy(file_type, token, sizeof(file_type) - 1);
                file_type[sizeof(file_type) - 1] = '\0';
            }

            col++;
            token = strtok(NULL, ",");
        }

        if (strlen(sha256) > 0) {
            sqlite3_reset(stmt);
            sqlite3_bind_text(stmt, 1, sha256, -1, SQLITE_TRANSIENT);
            sqlite3_bind_text(stmt, 2, file_name, -1, SQLITE_TRANSIENT);
            sqlite3_bind_text(stmt, 3, file_type, -1, SQLITE_TRANSIENT);
            sqlite3_bind_text(stmt, 4, first_seen, -1, SQLITE_TRANSIENT);
            sqlite3_bind_text(stmt, 5, source_name, -1, SQLITE_TRANSIENT);
            
            rc = sqlite3_step(stmt);
            if (rc == SQLITE_DONE) {
                loaded++;
            } else if (rc == SQLITE_CONSTRAINT) {
                skipped++;
            } else {
                errors++;
                if (errors < 10) {
                    printf("ERROR line %d: %s\n", line_num, sqlite3_errmsg(db));
                }
            }
        } else {
            skipped++;
            if (skipped < 10) {
                printf("SKIPPED line %d - hash empty (col count: %d)\n", line_num, col);
            }
        }

        if (loaded % 10000 == 0 && loaded > 0) {
            sqlite3_exec(db, "COMMIT", NULL, NULL, NULL);
            sqlite3_exec(db, "BEGIN TRANSACTION", NULL, NULL, NULL);
            printf("Progress: %d loaded, %d skipped, %d errors, %d truncated (line %d)\n", 
                   loaded, skipped, errors, truncated, line_num);
        }
    }

    if (feof(fp)) {
        printf("\nReached end of file normally\n");
    } else if (ferror(fp)) {
        printf("\nERROR reading file!\n");
        log_error("File read error occurred");
    }
    
    long final_pos = ftell(fp);
    printf("Final position: %ld / %ld bytes (%.1f%%)\n", 
           final_pos, file_size, (100.0 * final_pos) / file_size);

    sqlite3_exec(db, "COMMIT", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA synchronous = NORMAL", NULL, NULL, NULL);
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    fclose(fp);

    printf("\n=== SUMMARY ===\n");
    printf("Total lines processed: %d\n", line_num);
    printf("Successfully loaded: %d\n", loaded);
    printf("Skipped: %d\n", skipped);
    printf("Truncated: %d\n", truncated);
    printf("Errors: %d\n", errors);

    char msg[256];
    snprintf(msg, sizeof(msg), "Loaded %d malware hashes from %s", loaded, csv_path);
    log_info(msg);

    return loaded;
}